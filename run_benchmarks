#!/usr/bin/env python3

import psutil
import os
import subprocess
import time
import datetime as dt
import platform
import psutil
import cpuinfo
import subprocess
import json
import os
import socket
from benchmarks.util import download_datasets

def get_cpuinfo():
    info = {}
    info["cpu.architecture"] = platform.processor()
    info["cpu.model"] = cpuinfo.get_cpu_info().get('brand_raw', 'unknown')
    info["cpu.count"] = psutil.cpu_count(logical=False)
    info["cpu.count_logical"] = psutil.cpu_count(logical=True)
    info["cpu.freq_MHz"] = psutil.cpu_freq().max
    return info

def get_meminfo():
    info = {}
    try:
        out = subprocess.check_output(["lshw", "-C", "memory", "-json"], stderr=subprocess.STDOUT, text=True)
        mem = json.loads(out)
        for item in mem:
            if "bank" in item.get("id", ""):
                info["mem.description"] = item.get("description", "")
                info["mem.width_bits"] = item.get("width", "")
                info["mem.clock_MHz"] = item.get("clock", 0) / 1e6
                break

                
    except Exception:
        info["mem.description"] = ""
        info["mem.width_bits"] = ""
        info["mem.clock_MHz"] = ""

    return info

def read_first_matching_line(path):
    try:
        with open(path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read().strip()
    except Exception:
        return ""
    
def get_device_attr(dev, attr):
    # Works for SATA/SAS/NVMe with slight differences; many expose device/{model,vendor}
    p = f"/sys/block/{dev}/device/{attr}"
    return read_first_matching_line(p)

def list_block_devices():
    try:
        return sorted(d for d in os.listdir("/sys/block") if os.path.exists(f"/sys/block/{d}/device"))
    except Exception:
        return []

def is_rotational(dev):
    path = f"/sys/block/{dev}/queue/rotational"
    val = read_first_matching_line(path)
    if val is None:
        return None
    return val.strip() == "1"

def get_block_size_bytes(dev):
    # sector count * 512 (Linux logical sector default; could read /sys/block/DEV/queue/hw_sector_size if needed)
    sectors = read_first_matching_line(f"/sys/block/{dev}/size")
    if not sectors:
        return None
    try:
        return int(sectors) * 512
    except Exception:
        return None

 
def get_diskinfo(cache_folder):
    """
    Gets information about the mount point and disk (if available) that is hosting the cache folder.
    """
    print(cache_folder)

    # Get the device ID for the target path
    try:
        target_dev = os.stat(cache_folder).st_dev
    except FileNotFoundError:
        return f"Error: Path '{cache_folder}' not found."
    # Loop through all mount points to find the matching one
    # /proc/mounts is the most reliable on Linux
    try:
        with open("/proc/mounts", "r") as f:
            for line in f:
                parts = line.split()
                device, mountpoint, fs_type = parts[0], parts[1], parts[2]
                if mountpoint == '/': # Special case for root directory
                    mountpoint_dev = os.stat(mountpoint).st_dev
                elif os.path.isdir(mountpoint):
                    mountpoint_dev = os.stat(mountpoint).st_dev
                else:
                    continue
                
                if target_dev == mountpoint_dev:
                    mount = {
                        "mount.path": cache_folder,
                        "mount.device": device,
                        "mount.fs_type": fs_type
                    }
    except FileNotFoundError:
        # Fallback for systems without /proc/mounts
        mount = {
                        "mount.path": cache_folder,
                        "mount.device": "unknown",
                        "mount.fs_type": "unknown"
                    }
    disks = []
    for dev in list_block_devices():
        # Skip virtual devices we don't want to attribute capacity to (loop, ram, dm- are mappers)
        if dev.startswith("loop") or dev.startswith("ram") or dev.startswith("fd") or dev.startswith("dm-"):
            continue
        size_b = get_block_size_bytes(dev)
        rot = is_rotational(dev)
        model = get_device_attr(dev, "model")
        vendor = get_device_attr(dev, "vendor")
        # NVMe sometimes uses different attributes
        if model is None and dev.startswith("nvme"):
            model = get_device_attr(dev, "model") or read_first_matching_line(f"/sys/block/{dev}/device/device/model")
            vendor = get_device_attr(dev, "vendor") or read_first_matching_line(f"/sys/block/{dev}/device/device/vendor")

        # Interface type guess (very rough)
        interface = None
        try:
            # e.g., /sys/block/sda/device/subsystem -> .../scsi/
            subsys = os.path.realpath(f"/sys/block/{dev}/device/subsystem")
            if "nvme" in subsys:
                interface = "NVMe"
            elif "scsi" in subsys:
                interface = "SCSI/SATA/SAS"
        except Exception:
            pass

        disks.append({
            "device": dev,
            "size_gb": size_b/1e9,
            "interface": interface,
            "model": model,
            "vendor": vendor,
        })

    print(mount)
    print(disks)

    return disks

def get_machine(cache_folder):

    machine = {
        "hostname": socket.gethostname(),
        "os.system": platform.system(),
        "os.release": platform.release(),
        "os.version": platform.version(),
        "os.machine": platform.machine(),
    }
    machine.append(get_cpuinfo())
    machine.append(get_meminfo())
    machine.append(get_diskinfo(cache_folder))

    return machine


def main():

    dataset_folders, cache_folder = download_datasets()

    machine = get_machine(cache_folder)
    record = []
    for script in os.listdir("benchmarks"):
        if script.endswith(".py") and ("util.py" not in script):
            print(script)
            proc = subprocess.Popen(
                ["python", f"benchmarks/{script}"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            process = psutil.Process(proc.pid)
            peak_memory_rss = 0  # Resident Set Size
            start_time = time.time()
            while proc.poll() is None:  # While the subprocess is still running
                try:
                    mem_info = process.memory_info()
                    peak_memory_rss = max(peak_memory_rss, mem_info.rss)
                except psutil.NoSuchProcess:
                    # The process might have terminated between the poll() and memory_info() call
                    break
                time.sleep(0.01)  # Adjust sleep interval as needed for desired granularity
            end_time = time.time()
            result = {
                "benchmark.timestamp_utc": dt.datetime.utcnow().isoformat() + "Z",
                "benchmark.script": script,
                "benchmark.max_rss_bytes": peak_memory_rss,
                "benchmark.runtime_s": end_time - start_time,
                "benchmark.exit_status": proc.returncode,

            }

            record.append({**result, **machine})

    # Write a newline delimited json
    with open("benchmark_results.jsonl", "w") as f:
        for r in record:
            f.write(f"{r}\n")

if __name__ == "__main__":
    main()