#!/usr/bin/env python3

import psutil
import os
import subprocess
import time
import datetime as dt
import platform
import psutil
import cpuinfo
import subprocess
import json
import os
import socket
from benchmarks.util import download_datasets

def get_cpuinfo():
    info = {}
    info["cpu.architecture"] = platform.processor()
    info["cpu.model"] = cpuinfo.get_cpu_info().get('brand_raw', 'unknown')
    info["cpu.count"] = psutil.cpu_count(logical=False)
    info["cpu.count_logical"] = psutil.cpu_count(logical=True)
    info["cpu.freq_MHz"] = psutil.cpu_freq().max
    return info

def get_meminfo():
    info = {}
    try:
        out = subprocess.check_output(["lshw", "-C", "memory", "-json"], stderr=subprocess.STDOUT, text=True)
        mem = json.loads(out)
        for item in mem:
            if "bank" in item.get("id", ""):
                info["mem.description"] = item.get("description", "")
                info["mem.width_bits"] = item.get("width", "")
                info["mem.clock_MHz"] = item.get("clock", 0) / 1e6
                break

                
    except Exception:
        info["mem.description"] = ""
        info["mem.width_bits"] = ""
        info["mem.clock_MHz"] = ""

    return info

def read_first_matching_line(path):
    try:
        with open(path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.read().strip()
    except Exception:
        return ""
    
def get_device_attr(dev, attr):
    # Works for SATA/SAS/NVMe with slight differences; many expose device/{model,vendor}
    p = f"/sys/block/{dev}/device/{attr}"
    return read_first_matching_line(p)

def list_block_devices():
    try:
        return sorted(d for d in os.listdir("/sys/block") if os.path.exists(f"/sys/block/{d}/device"))
    except Exception:
        return []

def is_rotational(dev):
    path = f"/sys/block/{dev}/queue/rotational"
    val = read_first_matching_line(path)
    if val is None:
        return None
    return val.strip() == "1"

def get_block_size_bytes(dev):
    # sector count * 512 (Linux logical sector default; could read /sys/block/DEV/queue/hw_sector_size if needed)
    sectors = read_first_matching_line(f"/sys/block/{dev}/size")
    if not sectors:
        return None
    try:
        return int(sectors) * 512
    except Exception:
        return None

 
def get_diskinfo(cache_folder):
    """
    Gets information about the mount point and disk (if available) that is hosting the cache folder.
    """

    # Get the device ID for the target path
    try:
        target_dev = os.stat(cache_folder).st_dev
    except FileNotFoundError:
        return f"Error: Path '{cache_folder}' not found."
    # Loop through all mount points to find the matching one
    # /proc/mounts is the most reliable on Linux
    try:
        with open("/proc/mounts", "r") as f:
            for line in f:
                parts = line.split()
                device, mountpoint, fs_type = parts[0], parts[1], parts[2]
                if mountpoint == '/': # Special case for root directory
                    mountpoint_dev = os.stat(mountpoint).st_dev
                elif os.path.isdir(mountpoint):
                    mountpoint_dev = os.stat(mountpoint).st_dev
                else:
                    continue
                
                if target_dev == mountpoint_dev:
                    mount_path = mountpoint
                    mount = {
                        "mount.fs_type": fs_type
                    }
    except FileNotFoundError:
        mount = {"mount.fs_type": "unknown"}

    # Seek out the parent physical device that hosts the mount point
    # This ensures that we identify the physical device, based on whether
    # it or any of its children partitions host the mount point.
    try:
        lsblk_output = subprocess.check_output(["lsblk", "--json"], text=True)
        lsblk_data = json.loads(lsblk_output)
    except Exception:
        lsblk_data = {"blockdevices": []}

    for block_device in lsblk_data.get("blockdevices", []):
        if mount_path in block_device.get("mountpoints"):
            mount["mount.device"] = block_device.get("name")
            break

        if "children" in block_device:
            # Check children (partitions)
            for child in block_device.get("children", []):
                if mount_path in child.get("mountpoints"):
                    mount["mount.device"] = block_device.get("name")
                    break

                # Additional children check for virtual devices like LVM, RAID, etc.
                if "children" in child:
                    for grandchild in child.get("children", []):
                        if mount_path in grandchild.get("mountpoints"):
                            mount["mount.device"] = block_device.get("name")
                            break

    # Now that we know the block device name, we can get more info about it

    size_b = get_block_size_bytes(mount["mount.device"]) if "mount.device" in mount else -1
    rot = is_rotational(mount["mount.device"]) if "mount.device" in mount else None
    model = get_device_attr(mount["mount.device"], "model") if "mount.device" in mount else None
    vendor = get_device_attr(mount["mount.device"], "vendor") if "mount.device" in mount else None
    # NVMe sometimes uses different attributes
    if model is None and mount.get("mount.device", "").startswith("nvme"):
        model = get_device_attr(mount["mount.device"], "model") or read_first_matching_line(f"/sys/block/{mount['mount.device']}/device/device/model")
        vendor = get_device_attr(mount["mount.device"], "vendor") or read_first_matching_line(f"/sys/block/{mount['mount.device']}/device/device/vendor")

    # Interface type guess (very rough)
    interface = None
    try:
        # e.g., /sys/block/sda/device/subsystem -> .../scsi/
        subsys = os.path.realpath(f"/sys/block/{mount['mount.device']}/device/subsystem")
        if "nvme" in subsys:
            interface = "NVMe"
        elif "scsi" in subsys:
            interface = "SCSI/SATA/SAS"
    except Exception:
        pass

    mount = mount | {
            "mount.size_gb": size_b/1e9,
            "mount.interface": interface,
            "mount.model": model,
            "mount.vendor": vendor,
        }

    return mount

def get_machine(cache_folder):

    machine = {
        "hostname": socket.gethostname(),
        "os.system": platform.system(),
        "os.release": platform.release(),
        "os.version": platform.version(),
        "os.machine": platform.machine(),
    }
    machine = machine | get_cpuinfo()
    machine = machine | get_meminfo()
    machine = machine | get_diskinfo(cache_folder)

    return machine


def main():

    cache_folder = download_datasets()
    cache_folder = list(cache_folder.values())[0]


    machine = get_machine(cache_folder)

    record = []
    for script in os.listdir("benchmarks"):
        if script.endswith(".py") and ("util.py" not in script):
            print(script)
            proc = subprocess.Popen(
                ["python", f"benchmarks/{script}"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            process = psutil.Process(proc.pid)
            peak_memory_rss = 0  # Resident Set Size
            start_time = time.time()
            while proc.poll() is None:  # While the subprocess is still running
                try:
                    mem_info = process.memory_info()
                    peak_memory_rss = max(peak_memory_rss, mem_info.rss)
                except psutil.NoSuchProcess:
                    # The process might have terminated between the poll() and memory_info() call
                    break
                time.sleep(0.01)  # Adjust sleep interval as needed for desired granularity
            end_time = time.time()
            result = {
                "benchmark.timestamp_utc": dt.datetime.utcnow().isoformat() + "Z",
                "benchmark.script": script,
                "benchmark.max_rss_bytes": peak_memory_rss,
                "benchmark.runtime_s": end_time - start_time,
                "benchmark.exit_status": proc.returncode,

            }

            record.append({**result, **machine})

    # Write a newline delimited json
    with open("benchmark_results.jsonl", "a") as f:
        for r in record:
            f.write(f"{r}\n")

if __name__ == "__main__":
    main()